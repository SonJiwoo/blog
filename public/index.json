[{"content":"Part 2-1. 데이터 엔지니어 기초 다지기 본 포스팅은 패스트캠퍼스(FastCampus)의 데이터 엔지니어링 올인원 패키지 Online을 참고하였습니다.\n1. Unix 환경 및 커맨드 cd\nmkdir\nls\ncp\n./run.sh\nchmod +x run.sh: Permission denied 되었을 때, 권한 부여하기\nrun.sh 코드(참고용) #!/bin/bash\rpython examply.py 1 \u0026gt; example.txt\rpython examply.py 2 \u0026gt; example.txt\r*주의사항: python 대신에 python3를 쓰면 Windows에서는 오류가 날 수도 있다.\n2. AWS 기초 및 CLI 세팅 AWS CLI (Command Line Interface) 다운로드\n IAM에서 사용자 추가하기 Windows Powershell에다가 aws configure 입력하기 액세스 키 ID와 비밀 액세스 키 입력하기  이는 앞으로 shell에서 aws command를 쳐도 가능하게끔 세팅해놓는 것이다.\n","description":"데이터 엔지니어 기초 다지기","id":0,"section":"posts","tags":null,"title":"Unix \u0026 AWS","uri":"https://jiwooblog.netlify.app/posts/dataengineering/fc_part2_1/"},{"content":"Chapter 01. Introduction and Examples 본 포스팅은 First Course in Bayesian Statistical Methods를 참고하였다.\n이번 장을 통해서는 Likelihood and Prior를 살펴보고 Full probability model의 의미를 보는 데에 주목해보쟈.\n베이지안 추론의 목적 우리는 데이터 획득을 통해, 모집단 특성에 대한 불확실성을 줄여나가고자 한다. 이때, 불확실성 정도의 변화 수준을 계량화하는 것이 베이지안 추론통계의 목적이라고 할 수 있다.\n핵심 개념  prior distribution $p(\\theta)$  사전확률 모수에 대해 기존에 갖고 있던 믿음의 정도   sampling model $p(y|\\theta)$  일종의 가능도 함수(likelihood) 사전확률이 참이라는 가정 하에, 특정 데이터가 관찰된 확률   posterior distribution $p(\\theta|y)$  데이터가 관찰되었을 때, 이를 바탕으로 수정된 모수에 대한 믿음의 정도    Bayes' Rule $$p(\\theta|y) = \\frac{p(y|\\theta)p(\\theta)}{\\int_{\\Theta}p(y|\\tilde{\\theta})p(\\tilde{\\theta})d\\tilde{\\theta}}$$\n이는 사후분포가 사전분포와 가능도 함수에 의해 어떻게 업데이트 되는지를 수식적으로 나타난 것이다.\n베이즈 통계의 전부라고 해도 무방하다.\n활용예시  희소사건 확률 추정(Estimation)  감염 확률(infectious probability) 확률론자(frequentist)는 sample이 적을 때 확률추정을 합리적으로 하는 데에 있어서 취약할 수 있다. 예를 들어, 20명만을 대상으로 감염 여부를 확인하고 감염 확률을 추론한다면, 감염확률을 0%라고 제안하는 것은 통계적으로는 그럴 듯하게 계산될 수 있다. 하지만 이는 현실과는 다소 거리가 있을 수 있다. 이에 반해, 베이지안은 감염 확률을 분포로서 제시할 뿐더러 기존의 믿음을 사전확률로서 제안하기 때문에 이러한 부분에 있어서 덜 취약할 수 있다.   예측 모델 구축(Prediction)  당뇨병(diabetes progression) 50% 확률로 변수의 coefficient가 0라고 사전확률을 제안한다면, 변수선택의 효과를 얻을 수 있다.    ETC  \u0026lsquo;Adjusted\u0026rsquo; Wald interval\n흔히 알려진 신뢰구간을 베이지안적으로 바꾼 형태이다.  `\\hat{\\theta} \\pm 1.96\\sqrt{\\hat{\\theta}(1-\\hat{\\theta})//n}` , where `\\hat{\\theta} = \\frac{n}{n+4}\\bar{y} + \\frac{4}{n+4}\\frac{1}{2}`\n Lasso\n변수 선택의 한 방법이다. 아래 제시된 SSR를 최소화하는 것을 목표로 한다. 베이지안의 맥락에서 처음 연구된 방법론은 아니지만, 특정 사전확률을 적용한다면 베이지안의 관점과 일치한다.\n$$SSR(\\beta:\\lambda) = \\sum_{i=1}^{n}(y_i-\\boldsymbol{x_i}^T\\boldsymbol{\\beta})^2 + \\lambda\\sum_{j=1}^{n}|\\beta_j|$$  Conclusion \"All models are wrong, but some are useful\" - Box and Draper, 1987 혹시 궁금한 점이나 잘못된 내용이 있다면, 댓글로 알려주시면 적극 반영하도록 하겠습니다. ","description":"Introduction and Examples","id":1,"section":"posts","tags":null,"title":"FCB Ch01.","uri":"https://jiwooblog.netlify.app/posts/statistics/bayesian/fcb01/"},{"content":"Vector Space  덧셈에 닫혀있다. 스칼라배에 닫혀있다.  Subspace 벡터공간 $V_n$ 의 부분 집합 $W_n$이 벡터공간이면, $W_n$을 $V_n$의 부분공간이라고 한다. 즉, $W_n$이 부분공간이려면, 덧셈과 스칼라배에 닫혀있으면 된다.\nGauss-Jordan Elimination  확장행렬을 기약행사다리꼴(RREF, reduced row echelon form)로 바꾸는 알고리즘 가우스조던 소거법 = 가감법 + 대입법  선형사상의 특징  가산성 $f(x+y) = f(x) + f(y)$ 동차성 $f(ax) = af(x)$  LU Decomposition $E_{k}...E_{2}E_{1}A = U$\n=\u0026gt; $A = E_{1}^{-1}E_{2}^{-1}...E_{k}^{-1}U = LU$  여기서 $E_{k}...E_{2}E_{1}$는 하삼각행렬이며, $E_{1}^{-1}E_{2}^{-1}...E_{k}^{-1}$도 하삼각행렬이다.\n  근거(1) 가우스 소거법을 시행할 때 사용되는 모든 기본행렬은 항상 하삼각행렬이다. (단, 행교환 제외) 근거(2) 하삼각행렬인 기본행렬의 역행렬은 여전히 하삼각행렬이다. 근거(3) 하삼각행렬 $\\times$ 하삼각행렬 = 하삼각행렬 PLU Decomposition 행교환이 필요한 경우, 행교환을 미리 해주고 LU 분해하는 법 (P: permutation)\n용어 정리  consistent: 해가 적어도 한 개는 있는 경우 homogeneous: 동차 (ex. $A\\vec{x} = \\vec{0}$: 동차 연립선형방정식)  ","description":"Intro","id":2,"section":"posts","tags":null,"title":"Lecture 01","uri":"https://jiwooblog.netlify.app/posts/statistics/linearalgebra/l01/"},{"content":"심리학 수강 과목  심리학개론 충동과자기관리 심리학의 실험연구방법 발달심리학 행복의 과학 언어심리학 이론 및 실습 인지신경과학의 기초 심리통계 학습과 기억의 심리학 UT세미나(실패와 좌절의 심리학) 성격심리학 재능과 기술의 심리학 인지공학심리학 산업심리학  ","description":"","id":3,"section":"posts","tags":null,"title":"수강과목","uri":"https://jiwooblog.netlify.app/posts/yonsei/psychology/lecture/"},{"content":"통계학 수강 과목  통계학입문 미분적분학 통계방법론 선형대수 컴퓨터자료처리 심리통계 데이터사이언스를 위한 확률과정 회귀분석 수리통계학(1) 베이즈통계 수리통계학 (2) 시계열분석 금융리스크관리 실무와 통계학 UT세미나(생물통계학) 범주형자료분석 데이터사이언스입문 데이터마이닝 이론통계학(1) 데이터사이언스(2): 네트워크 자료분석  ","description":"","id":4,"section":"posts","tags":null,"title":"수강과목","uri":"https://jiwooblog.netlify.app/posts/yonsei/statistics/lecture/"},{"content":"NH투자증권 Y\u0026amp;Z세대 투자자 프로파일링 본 대회는 NH투자증권에서 주최한 대회로, 2020년 급격하게 늘어난 20~30대 투자자들에 대한 분석을 하고 이를 시각화하는 것이 주목적이었다.\n코드가 상당히 복잡한 관계로 Dacon에 코드공유한 링크와 이미지 일부를 올리는 것으로 포스팅을 대체하고자 한다.\nDacon 코드 공유 Factor Analysis Word Cloud_국내 Word Cloud_해외 Cluster Polygon Cluster Characteristics Idea Table Idea Sample Domain Knowledge 1. 해외주식 소수점 거래  현재 신한금융투자, 한국투자증권에서 실현 중 의결권, 배당권을 빼고 소수점 거래 가능! (ex. 한투 미니스톡)  2. 휴면 고객에 대한 이벤트도 주기적으로 한다. 3. ETP (= ETF + ETN) 금융투자협회: 한눈에 알아보는 레버리지 ETP Guide\n  괴리율\n 순자산가치(NAV) \u0026amp; 지표가치(IV)은 장중 실시간으로 산출한다.  전일 종가로 확정된 순자산 가치 + 당일의 가격 움직임   괴리율이 플러스(+): 추적대상 지수보다 고평가되어 있다(=비싸게 거래되고 있다). 괴리율이 마이너스(-): 추적대상 지수보다 저평가되어 있다(=싸게 거래되고 있다.) 괴리율이 너무 커지면, 한국거래소에서 단일가 매매 또는 매매거래정지를 시킬 수 있다. 유동성공급자(Liquidity Provider, LP)  괴리율이 과도하게 높을 경우: ETP를 매도하거나 대상자산을 매입해야겠다! 괴리율이 과도하게 낮을 경우: ETP를 매수하거나 대상자산을 매도해야겠다!      복리 효과\n 레버리지 ETP의 운용방식: \u0026lsquo;일별\u0026rsquo; 수익률의 ±2배 상승장일 경우, 2X의 상승률 \u0026gt; 인버스2X 하락률 하락장일 경우, 2X의 하락률 \u0026lt; 인버스2X 상승률 횡보장일 경우, 2X와 인버스2X 모두 손해볼 가능성이 높다. 즉, 장기투자에 적합하지 않다. 상식: 레버리지 상품을 만들기 위해서는 파생상품을 집어넣는다.    롤오버(roll-over)\n 파생상품의 거래월물을 교체하는 것(파생상품의 만기에 발생) 즉, 롤오버 과정에서 거래월물의 가겨차이에 따라 ETP의 자산가치 변동이 이루어질 수 있다. 선물 \u0026lsquo;매수\u0026rsquo;포지션을 보유하고 있는 레버리지(2X) ETP  거래월물의 가격차이가 (+)상태이면 이득, (-)상태이면 손해   선물 \u0026lsquo;매도\u0026rsquo;포지션을 보유하고 있는 레버리지(2X) ETP  거래월물의 가격차이가 (+)상태이면 손해, (-)상태이면 이득      지수의 방법론\n 괴리율, 복리효과, 롤오버만큼의 중요성은 아니지만, 간과해서는 안되는 POINT ex) 2020년 4월 유례 없는 마이너스 유가 폭락으로 인한 원유선물의 거래월물 편입대상과 롤오버 방식 변화    배운 점 1. 크롤링 능력  크롤링은 Python을 통해서 진행하였다. BeautifulSoup, selenium의 webdriver 등의 라이브러리를 활용하였다. (1) 해외사이트 크롤링의 어려움  느리고, 자잘한 오류가 생긴다. 예를 들어, 특정 단어를 검색을 해도 나오지 않는다.   (2) 크롤링 권한 접근  접근 권한의 제한으로 단순 크롤링을 할 수 없는 경우\nNetwork-XHR의 Request Headers 활용하기 에러 핸들링 관점에서 데이터 엔지니어링의 중요성 체감    2. 파생변수 제작의 어려움  run_away_cd(휴면 여부) 라는 변수를 새롭게 만들었다. 총 세가지 기준에 의해 각 고객의 휴면 여부를 판단하였는데, 그 기준은 다음과 같다.  (1) 거래주기에 비해 거래휴식기가 지나치게 긴 경우 (2) 예상 거래횟수에 비해 실제 거래횟수가 눈에 띄게 적은 경우 (3) 최근 2달 이내에 계좌개설한 사람들은 제외   해당 변수를 만들고 유의성을 검토하는 데에 적지 않은 시간을 투자하였던 경험👍 해당 변수를 만들기 위해, 중간과정에서 orr_prd, orr_cyl, orr_idx_1, orr_idx2를 만들었다.  3. 요인분석 Factor 조합 노하우  어려운 변수보다는 직관적으로 간단한 변수들의 조합으로 구성하는 것이 좋다.. 왜냐하면 요인분석 자체가 해석을 목적으로 하기 때문이다.  ","description":"","id":5,"section":"posts","tags":null,"title":"YZ 투자자 프로파일링","uri":"https://jiwooblog.netlify.app/posts/dacon/nh_yz/"},{"content":"Part 2-2. 데이터 엔지니어 기초 다지기 본 포스팅은 패스트캠퍼스(FastCampus)의 데이터 엔지니어링 올인원 패키지 Online을 참고하였습니다.\n3. SQLite Studio SQLite Studio 다운로드\n데이터 다운로드  editor 여는 법: Tools \u0026gt; Open SQL Editor (or Alt + E) SQLite과 MySQL을 포함한 다른 프로그램들과 코드가 다른 것들이 사소하게 있을 수 있다.  SQL 기본 문법 (1) SELECT 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  SELECT * FROM Salaries LIMIT 10; SELECT * FROM Salaries ORDER BY salary DESC LIMIT 10; SELECT * FROM Salaries WHERE yearID = \u0026#39;2010\u0026#39; AND lgID = \u0026#39;AL\u0026#39; ORDER BY salary DESC LIMIT 20; --SUM, AVG SELECT SUM(salary) FROM Salaries WHERE playerID = \u0026#39;rodrial01\u0026#39;; --Concat, Count, Group By SELECT nameFirst || \u0026#39; \u0026#39; || nameLast AS name FROM People Limit 10; SELECT nameFirst || \u0026#39; \u0026#39; || nameLast AS name FROM People Where playerID = \u0026#39;rodrial01\u0026#39;; SELECT COUNT(DISTINCT(nameFirst || \u0026#39; \u0026#39; || nameLast)) FROM People; SELECT nameFirst || \u0026#39; \u0026#39; || nameLast AS name, COUNT(*) FROM People GROUP BY name HAVING COUNT(*) \u0026gt; 1; SELECT teamID, SUM(Salary) as total_salary FROM Salaries GROUP BY teamID ORDER BY total_salary DESC;   SQL 기본 문법 (2) JOIN 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  --Join SELECT t2.nameFirst ||\u0026#39; \u0026#39;||t2.nameLast AS name, t1.salary FROM Salaries t1 JOIN People t2 ON t2.playerID = t1.playerID ORDER BY salary DESC LIMIT 20; --Quiz. Top paid player for each team in 2010 SELECT t1.teamID, t2.nameFirst||\u0026#39; \u0026#39;||t2.nameLast AS name, t1.salary --using MAX(salary) instead of ORDER BY would be more efficient FROM Salaries t1 JOIN People t2 ON t2.playerID = t1.playerID WHERE t1.yearID = \u0026#39;2010\u0026#39; GROUP BY teamID ORDER BY salary DESC; -- Left Join, Right Join SELECT t1.playerID, COUNT(*) FROM People t1 LEFT JOIN AllstarFull t2 ON t2.playerID = t1.playerID GROUP BY 1 ORDER BY COUNT(*) DESC LIMIT 20;   SQL 기본 (3) 데이터 타입들 및 키 값들, 테이블 생성 Primary Key: 빠른 처리, 중복 처리를 위해서 설정하기도 함!\nForeign Key: 다른 테이블에서 온 칼럼 처리\nUnique: 중복 처리 방지\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  -- 데이터베이스 테이블 생성 CREATE TABLE mytable (id INT, name VARCHAR(255), debut DATE); CREATE TABLE mytable2 (id INTEGER PRIMARY KEY AUTOINCREMENT, name VARCHAR(255), debut DATE); INSERT INTO mytable2 (name, debut) VALUES (\u0026#39;jiwoo\u0026#39;, \u0026#39; 2000-09-01\u0026#39;); SELECT * FROM mytable2; --INSERT INSERT INTO mytable2 (name, debut) VALUES (\u0026#39;jiwoo\u0026#39;, \u0026#39;2000-09-05\u0026#39;); SELECT * FROM mytable2; --Update UPDATE mytable2 SET debut = \u0026#39;2010-09-01\u0026#39; WHERE id = 1; --Replace REPLACE INTO mytable2 (id, name, debut) VALUES (5, \u0026#39;jiwoo2\u0026#39;, \u0026#39;2015-09-01\u0026#39;); -- Update는 기존의 값이 없다면 아무런 행동도 하지 않지만, Replace는 기존의 값이 없다면 새로 만들어버린다는 차이점이 있다.  --Insert Or Ignore INSERT OR IGNORE INTO mytable2 (id, name, debut) VALUES (1, \u0026#39;jiwoo3\u0026#39;, \u0026#39;2010-09-11\u0026#39;); --이미 id가 1인 행이 있을 경우, 그냥 insert into만 하면 \u0026#39;unique constraint failed\u0026#39;가 뜨지만 or ignore을 추가해주면 괜찮다.  -- Delete, ALter, Drop -- 아주아주 신중하게 써야하는 커맨드들이다! SELECT * FROM mytable2; Delete FROM mytable2 WHERE id=1; ALTER TABLE mytalbe2 RENAME TO players; ALTER TABLE players ADD COLUMN DOB date; SELECT * FROM players; DROP TABLE mytable;  \nSQL 기본 (4) Functions 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  -- Functions(1) 기본처리 및 연산 SELECT * FROM players; SELECT SUBSTR(name, 1, 3) FROM players; SELECT UPPER(name) FROM players; SELECT AVG(LENGTH(name)) FROM players; --MAX, AVG, COUNT, SUM  -- Functions(2) 날짜데이터, Case When SELECT CURRENT_TIMESTAMP; --UTC기준 SELECT DATE(\u0026#39;NOW\u0026#39;); SELECT DATETIME(CURRENT_TIMESTAMP, \u0026#39;+1 DAY\u0026#39;); SELECT id, name, CASE WHEN name = \u0026#39;jiwoo\u0026#39; THEN \u0026#39;OK\u0026#39; WHEN name = \u0026#39;jiwoo2\u0026#39; THEN \u0026#39;OK2\u0026#39; ELSE \u0026#39;No OK\u0026#39; END AS ok_name, --CASE WHEN부터 여기까지가 variable 하나!  debut FROM players;   ","description":"데이터 엔지니어 기초 다지기","id":6,"section":"posts","tags":null,"title":"SQL 기초 (SQLite)","uri":"https://jiwooblog.netlify.app/posts/dataengineering/fc_part2_2/"},{"content":"\r\rChapter 02. Belief, Probability and Exchangeability\r본 포스팅은 First Course in Bayesian Statistical Methods를 참고하였다.\r이번 장의 목표는 independence와 exchangeability를 이해하는 것이다. 이를 바탕으로 de Finetti’s theorem이 Bayesian에 갖는 의의를 이해한다면, 베이즈 통계를 공부할 준비가 된 것이다.\nBelief functions and Probabilities\r$Be()$는 belief function이라고 하자. 예를 들어, $Be(F) \u0026gt; Be(G)$는 G보다 F를 더 믿는다고 해석하면 된다. F, G, H를 아래와 같은 각각의 상황이라고 가정해보자.\n\rF : 좌파 후보자를 투표하는 경우 G : 소득이 하위 10%에 속하는 경우 H : 대도시에 거주하는 경우\n\rAxioms of beliefs\r$Be($not $H|H) \\le Be(F|H) \\le Be(H|H)$\r$Be(F $ or $G|H) \\ge max(Be(F|H), Be(G|H))$\r$Be(F $ and $G|H)$ can be drvied from $Be(G|H)$ and $Be(F|G $ and $H)$\r\r\rAxioms of probability\r$0 = Pr($not $H|H) \\le Pr(F|H) \\le Pr(H|H) \\le = 1$\r$Pr(F \\cup G|H) = Pr(F|H) + Pr(G|H)$ if $F \\cap G = \\emptyset$\r$Pr(F \\cap G|H) = Pr(G|H)Pr(F|g \\cap H)$\r\rbelief와 probability에 대한 각각의 공리들이 매칭되므로, 우리는 믿음의 정도를 계산할 때 확률함수를 계산하는 것처럼 다뤄도 무방하다고 결론낼 수 있다.\n\r\rIndependence\r사건 F와 G는 아래와 같은 상황에서 조건부 독립(conditional independence)이라고 한다.\r\\[Pr(F \\cap G|H) = Pr(F|H)Pr(G|H)\\]\r이를 풀어서 해석해보자면, H를 알고 있는 상황에서, 추가적으로 G에 대해서 알게 되는 것은 F에 대한 믿음을 변화시키는 데에 영향이 없다는 것이다.\n\rExchangeability\r$Y_1, ..., Y_n$이 있을 때, 이 순서를 어떻게 섞더라도 결합확률은 바꾸지 않을 때 exchangeable하다고 한다. 이는 직관적으로 풀어쓴 것이며, 다시 한 번 수학적 정의로 자세히 써보자면 아래와 같다.\rLet $p(y_1, ... y_n)$ be the joint density of $Y_1, ..., Y_n$. If $p(y_1, ..., y_n) = p(y_{\\pi_1}, ..., y_{\\pi_n})$ for all permutations $\\pi$ of {1, …, n}, then $Y_1, ..., Y_n$ are exchangeable.\n\\[\\begin{equation}\r\\left.\\begin{aligned}\rY_1, ..., Y_n|\\theta \\text{ i.i.d} \\\\ \\theta \\sim p(\\theta)\r\\end{aligned}\\right\\} \\Rightarrow Y_1, ... Y_n \\text{ are exchangeable}\r\\end{equation}\\]\n\rde Finetti’s Theorem\r만약 $Y_1, ..., Y_n$이 exchangeability를 만족한다면, 아래와 같이 말할 수 있다.\n\\[p(y_1, ..., y_n) = \\int{\\Bigg\\{\\prod_{1}^{n}p(y_i|\\theta)\\Bigg\\} \\:p(\\theta)d\\theta} \\\\\r\\text{for some parameter} \\: \\theta\\]\n이는 확률변수 $Y_1, ..., Y_n$에 대해서 exchangeability를 만족한다면, $p(y_1, ..., y_n)$에 대해 $\\theta$라는 parameter를 활용하여 위와 같은 수식으로 나타낼 수 있다는 것이다. 그렇다면 이 정리가 베이지안에게 어떤 의미를 갖는 것일까? 이는 사전확률분포(prior model)와 가능도함수(sampling model)가 belief model $p(y_1, ..., y_n)$에 의존함을 의미한다. 풀어서 이야기하자면, parameter $\\theta$가 확률론자가 주장하는 것처럼 미지의 고정된 값이 아니라, 어떤 분포를 갖는 확률변수로 볼 수 있다는 것이다. (그리고 그것을 우리는 사전확률분포 prior distribution이라고 부른다.)\n\r주의사항\rBayes’ rule은 데이터를 접한 이후, 우리의 믿음이 어떻게 업데이트되는지에 대한 수식이다.\r여기서 헷갈리면 안되는 것이 있다. Bayes’ rule은 우리의 믿음이 어때야 하는지(should be)에 대해서 이야기하고 있는 것이 아니라 어떻게 변해야 하는지(should change)에 대해서 이야기하는 것이다.\n\rConclusion\r믿음(Belief)도 확률(Probability)로써 이야기할 수 있다.\rparamter $\\theta$는 분포를 갖는 확률변수이다.\r\n혹시 궁금한 점이나 잘못된 내용이 있다면, 댓글로 알려주시면 적극 반영하도록 하겠습니다.\r\n\r\r","description":"Belief, Probability and Exchangeability","id":7,"section":"posts","tags":null,"title":"FCB Ch02.","uri":"https://jiwooblog.netlify.app/posts/statistics/bayesian/fcb02/"},{"content":"\r\rVector Space\r덧셈에 닫혀있다.\r스칼라배에 닫혀있다.\r\r\rSubspace\r벡터공간 \\(V_n\\) 의 부분 집합 \\(W_n\\)이 벡터공간이면, \\(W_n\\)을 \\(V_n\\)의 부분공간이라고 한다. 즉, \\(W_n\\)이 부분공간이려면, 덧셈과 스칼라배에 닫혀있으면 된다.\n\rGauss-Jordan Elimination\r\r확장행렬을 기약행사다리꼴(RREF, reduced row echelon form)로 바꾸는 알고리즘\r가우스조던 소거법 = 가감법 + 대입법\r\r## speed dist ## Min. : 4.0 Min. : 2.00 ## 1st Qu.:12.0 1st Qu.: 26.00 ## Median :15.0 Median : 36.00 ## Mean :15.4 Mean : 42.98 ## 3rd Qu.:19.0 3rd Qu.: 56.00 ## Max. :25.0 Max. :120.00\rsummary(cars)\r## speed dist ## Min. : 4.0 Min. : 2.00 ## 1st Qu.:12.0 1st Qu.: 26.00 ## Median :15.0 Median : 36.00 ## Mean :15.4 Mean : 42.98 ## 3rd Qu.:19.0 3rd Qu.: 56.00 ## Max. :25.0 Max. :120.00\r\r","description":"Intro","id":8,"section":"posts","tags":null,"title":"Lecture 02_TEST","uri":"https://jiwooblog.netlify.app/posts/statistics/linearalgebra/l02/"},{"content":"\r\rVector Space\r덧셈에 닫혀있다.\r스칼라배에 닫혀있다.\r\r\rSubspace\r벡터공간 \\(V_n\\) 의 부분 집합 \\(W_n\\)이 벡터공간이면, \\(W_n\\)을 \\(V_n\\)의 부분공간이라고 한다. 즉, \\(W_n\\)이 부분공간이려면, 덧셈과 스칼라배에 닫혀있으면 된다.\n\rGauss-Jordan Elimination\r\r확장행렬을 기약행사다리꼴(RREF, reduced row echelon form)로 바꾸는 알고리즘\r가우스조던 소거법 = 가감법 + 대입법\r\r## speed dist ## Min. : 4.0 Min. : 2.00 ## 1st Qu.:12.0 1st Qu.: 26.00 ## Median :15.0 Median : 36.00 ## Mean :15.4 Mean : 42.98 ## 3rd Qu.:19.0 3rd Qu.: 56.00 ## Max. :25.0 Max. :120.00\rsummary(cars)\r## speed dist ## Min. : 4.0 Min. : 2.00 ## 1st Qu.:12.0 1st Qu.: 26.00 ## Median :15.0 Median : 36.00 ## Mean :15.4 Mean : 42.98 ## 3rd Qu.:19.0 3rd Qu.: 56.00 ## Max. :25.0 Max. :120.00\r\r","description":"Intro","id":9,"section":"posts","tags":null,"title":"Rmd Test","uri":"https://jiwooblog.netlify.app/posts/r/test/"},{"content":"Part 3. API는 무엇인가 본 포스팅은 패스트캠퍼스(FastCampus)의 데이터 엔지니어링 올인원 패키지 Online을 참고하였습니다.\n1. API 정의  Application Programming Interface 두 개의 시스템이 서로 상호작용하기 위한 인터페이스(데이터 주고 받기!) 일반적으로 API는 REST API를 지칭한다. ex) Web API: 웹을 통해 외부 서비스들로부터 정보를 불러오는 API  2. API 접근 권한  Authentication: Identity가 맞다는 증명 Authorization: API를 통한 어떠한 액션을 허용 둘은 다르다! Athentication을 하였다고 하더라도 Authorization을 허용하지 않을 수 있다! Security 이슈가 중요하다.  API Key?  보통 Request URL 혹은 Request Header에 포함되는 긴 스트링 ex) Google Maps Platform \u0026gt; Geocoding API  https://maps.googleapis.com/maps/api/geocode/json?address=1600+Amphitheatre+Parkway,+Mountain+View,+CA\u0026amp;key=YOUR_API_KEY 여기서 YOUR_API-KEY 이부분을 채워주지 않으면, request denied가 뜨게 된다.    Baisc Auth  username:password와 같은 credential을 Base64로 인코딩한 값을 Request Header 안에 포함  OAuth 2.0  End User \u0026lt;=\u0026gt; My App \u0026lt;=\u0026gt; Server(ex. Spotify) (1) App에서 End User한테 생일, 전화번호, 플레이리스트와 같은 정보를 가져가는 것에 대해서 동의를 받는다. (2) 동의서를 받아왔으니 Server한테 API 요청을 하고 그에 맞는 데이터를 요구한다.  3. Spotify Web API  Spotify 직접 방문해보기  4. Endpoints \u0026amp; Methods  Resource: API를 통해 리턴된 정보 Endpoint: Resource 안에는 여러 개의 Endpoints가 존재 Method: 자원 접근에 허용된 행위(GET, POST, PUT, DELETE)     Method Action     GET 해당 리소스를 조회하고 정보를 가져온다.   HEAD 응답코드와 HEAD만 가져온다.   POST 요청된 리소스를 생성한다.   PUT 요청된 리소스를 업데이트 한다.   DELETE 요청된 리소스를 삭제한다.    5. Parameters  Parameters: Endpoint를 통해 Request할 때 같이 전달하는 옵션들     Type 내용     Header Request Header에 포함. 주로 Authorization에 관련   Path Query String(?) 이전에 Endpoint Path 안에 포함. ex) id   Query String Query STring(?) 이후에 포함. ex) ?utm_source=facebook\u0026amp;\u0026hellip;   Request Body Request Body 안에 포함. 주로 JSON 형태    \n","description":"API는 무엇인가","id":10,"section":"posts","tags":null,"title":"API","uri":"https://jiwooblog.netlify.app/posts/dataengineering/fc_part3_1/"},{"content":"Chapter 03. One-parameter Models 본 포스팅은 First Course in Bayesian Statistical Methods를 참고하였다.\nBinomial Model 이항분포:\nPrior: Likelihood:\nPosterior:\nPoisson Model 포아송분포:\nPrior:\nLikelihood:\nPosterior:\nExponential Family Conjugate Prior Conclusion Conjugacy를 잘 알아두자. 혹시 궁금한 점이나 잘못된 내용이 있다면, 댓글로 알려주시면 적극 반영하도록 하겠습니다. ","description":"One-parameter Models","id":11,"section":"posts","tags":null,"title":"FCB Ch03.","uri":"https://jiwooblog.netlify.app/posts/statistics/bayesian/fcb03/"},{"content":"Chapter 04. Monte Carlo Approximation 본 포스팅은 First Course in Bayesian Statistical Methods를 참고하였다.\nMonte Carlo Method Sampling from Predictive Distributions Posterior Predictive Model Checking 혹시 궁금한 점이나 잘못된 내용이 있다면, 댓글로 알려주시면 적극 반영하도록 하겠습니다. ","description":"Monte Carlo Approximation","id":12,"section":"posts","tags":null,"title":"FCB Ch04.","uri":"https://jiwooblog.netlify.app/posts/statistics/bayesian/fcb04/"},{"content":"Part 3. API는 무엇인가 본 포스팅은 패스트캠퍼스(FastCampus)의 데이터 엔지니어링 올인원 패키지 Online을 참고하였습니다.\n1. Spotify App 생성 및 토큰 발급 Client Credentials Flow 1 2 3 4 5  { \u0026#34;access_token\u0026#34;: \u0026#34;NgCXRKc...MzYjw\u0026#34;, \u0026#34;token_type\u0026#34;: \u0026#34;bearer\u0026#34;, \u0026#34;expires_in\u0026#34;: 3600, }    client id, client secret을 제공하면 우리는 3600초, 즉 1시간동안 사용할 수 있다.  2. Python 기본 1 2 3 4 5 6 7 8 9 10 11  import sys def main(): print(\u0026#39;fastcampus\u0026#39;) #python으로 실행했을 때, 해당 py파일 이름이 전달되면, main()을 실행하라 if __name__ == \u0026#39;__main__\u0026#39;: main() #직접 py파일이 실행 안되고, import spotify_api와 같이 모듈처럼 import되면, ~~를 print하라. else: print(\u0026#39;this script i being imported\u0026#39;)    Windows는 Windows Powershell을 통해서 진행하면 된다. 기본적으로 위처럼 코딩을 시작하게 된다.  3. Python Requests 패키지 requests python library \u0026gt; Developer Interface 참고하기\npowershell에서 pip install requests 실행하기\n4. API를 통한 데이터 요청 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  import sys import requests import base64 import json import logging client_id = \u0026#39;\u0026#39; # client_id 입력 client_secret = \u0026#39;\u0026#39; # client_secret 입력 def main(): headers = get_headers(client_id, client_secret) params = { \u0026#39;q\u0026#39;: \u0026#39;BTS\u0026#39;, \u0026#39;type\u0026#39;: \u0026#39;artist\u0026#39;, \u0026#39;limit\u0026#39;: 5 } r = requests.get(\u0026#39;https://api.spotify.com/v1/search\u0026#39;, params=params, headers=headers) # print(r.status_code) # 200이면 이상 없는 것 # print(r.text) # sys.exit(0) def get_headers(client_id, client_secret): # 1시간만 있으면 expire되기 때문에 추가로 function 하나를 만들어두는 것이다. endpoint = \u0026#39;https://accounts.spotify.com/api/token\u0026#39; encoded = base64.b64encode(\u0026#34;{}:{}\u0026#34;.format(client_id, client_secret).encode(\u0026#39;utf-8\u0026#39;)).decode(\u0026#39;ascii\u0026#39;) headers = { \u0026#39;Authorization\u0026#39;: \u0026#39;Basic {}\u0026#39;.format(encoded) } payload = { \u0026#39;grant_type\u0026#39;: \u0026#39;client_credentials\u0026#39; } r = requests.post(endpoint, data=payload, headers=headers) # 중간에 잘 되는지 확인해보는 코드 # print(r.status_code) # print(r.text) # print(type(r.text)) #string으로 출력되므로 아래에서 json.loads를 통해 dictionary로 만들어줘야 한다. # sys.exit(0) access_token = json.loads(r.text)[\u0026#39;access_token\u0026#39;] headers = { \u0026#39;Authorization\u0026#39;: \u0026#34;Bearer {}\u0026#34;.format(access_token) } return headers if __name__ == \u0026#39;__main__\u0026#39;: main()   5. Status Code  Status Code를 알아야 하는 이유: 데이터 엔지니어의 잘못이 아닌, Spotify 서버의 오류 등으로 인한 문제인지 체크할 수 있다. Spotify Web API 기준이지만, RFC 2616와 RFC 6585에 의해 일반적으로 통용되는 기준이다.     STATUS CODE DESCRIPTION     200 OK - The request has succeeded. The client can read the result of the request in the body and the headers of the response.   201 Created - The request has been fulfilled and resulted in a new resource being created.   202 Accepted - The request has been accepted for processing, but the processing has not been completed.   204 No Content - The request has succeeded but returns no message body.   304 Not Modified. See Conditional requests.   400 Bad Request - The request could not be understood by the server due to malformed syntax. The message body will contain more information; see Response Schema.   401 Unauthorized - The request requires user authentication or, if the request included authorization credentials, authorization has been refused for those credentials.   403 Forbidden - The server understood the request, but is refusing to fulfill it.   404 Not Found - The requested resource could not be found. This error can be due to a temporary or permanent condition.   429 Too Many Requests - Rate limiting has been applied.   500 Internal Server Error. You should never receive this error because our clever coders catch them all … but if you are unlucky enough to get one, please report it to us through a comment at the bottom of this page.   502 Bad Gateway - The server was acting as a gateway or proxy and received an invalid response from the upstream server.   503 Service Unavailable - The server is currently unable to handle the request due to a temporary condition which will be alleviated after some delay. You can choose to resend the request again.    6. 에러 핸들링 sys.exit(0)과 sys.exit(1) 차이 1 2 3 4  # 프로그램을 정상적으로 종료시키고 싶을 때 sys.exit(0) # 프로그램을 강제적으로 종료시키고 싶을 때 sys.exit(1)   Status Code 401, 409 에러 핸들링 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  r = requests.get(\u0026#39;https://api.spotify.com/v1/search\u0026#39;, params=params, headers=headers) if r.status_code != 200: logging.error(r.text) ## Too many requests if r.status_code == 429: retry_after = json.loads(r.headers)[\u0026#39;Retry-After\u0026#39;] time.sleep(int(retry_after)) r = requests.get(\u0026#39;https://api.spotify.com/v1/search\u0026#39;, params=params, headers=headers) ## access_token expireed elif r.status_code == 401: headers = get_headers(client_id, client_secret) r = requests.get(\u0026#39;https://api.spotify.com/v1/search\u0026#39;, params=params, headers=headers) else: sys.exit(1) #강제종료   7. 페이지네이션 핸들링 참고사이트\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  import sys import requests import base64 import json import logging client_id = \u0026#39;\u0026#39; # client_id 입력 client_secret = \u0026#39;\u0026#39; # client_secret 입력 def main(): headers = get_headers(client_id, client_secret) # Get BTS\u0026#39; Albums r = requests.get(\u0026#39;https://api.spotify.com/v1/artists/3Nrfpe0tUJi4K4DXYWgMUX/albums\u0026#39;, headers=headers) raw = json.loads(r.text) # total = raw[\u0026#39;total\u0026#39;] # 총 104개가 있음을 확인 # offset = raw[\u0026#39;offset\u0026#39;] # 시작은 0 # limit = raw[\u0026#39;limit\u0026#39;] # 20개씩 뽑겠다. next = raw[\u0026#39;next\u0026#39;] albums = [] albums.extend(raw[\u0026#39;items\u0026#39;]) ## 난 200개만 뽑아 오겠다. count = 0 while count \u0026lt; 200 and next: # while next: 라고만 하면 끝까지 가져오게 된다. r = requests.get(raw[\u0026#39;next\u0026#39;], headers=headers) raw = json.loads(r.text) next = raw[\u0026#39;next\u0026#39;] # print(next) # 맨 마지막에는 none이 나오게 된다. 이에 대해서는 Spotify 페이지를 참고하면 된다. albums.extend(raw[\u0026#39;items\u0026#39;]) count = len(albums) print(len(albums)) def get_headers(client_id, client_secret): endpoint = \u0026#39;https://accounts.spotify.com/api/token\u0026#39; encoded = base64.b64encode(\u0026#34;{}:{}\u0026#34;.format(client_id, client_secret).encode(\u0026#39;utf-8\u0026#39;)).decode(\u0026#39;ascii\u0026#39;) headers = {\u0026#39;Authorization\u0026#39;: \u0026#39;Basic {}\u0026#39;.format(encoded)} payload = {\u0026#39;grant_type\u0026#39;: \u0026#39;client_credentials\u0026#39;} r = requests.post(endpoint, data=payload, headers=headers) access_token = json.loads(r.text)[\u0026#39;access_token\u0026#39;] headers = {\u0026#39;Authorization\u0026#39;: \u0026#34;Bearer {}\u0026#34;.format(access_token)} return headers if __name__ == \u0026#39;__main__\u0026#39;: main()   \n","description":"API는 무엇인가","id":13,"section":"posts","tags":null,"title":"Spotify API","uri":"https://jiwooblog.netlify.app/posts/dataengineering/fc_part3_2/"},{"content":"Chapter 05. Normal Model 본 포스팅은 First Course in Bayesian Statistical Methods와 Bayesian Data Analysis를 참고하였다.\nWarm up! Gamma Distribution Inverse Gamma Distribution Scaled Inverse Chi-squared Distribution Single Parameter Conjugacy unknown ${\\sigma}^2$ unknown ${\\mu}$ Two Parameter Conjugacy unknown ${\\sigma}^2, {\\mu}$ semi-conjugacy 혹시 궁금한 점이나 잘못된 내용이 있다면, 댓글로 알려주시면 적극 반영하도록 하겠습니다. ","description":"Normal Model","id":14,"section":"posts","tags":null,"title":"FCB Ch05.","uri":"https://jiwooblog.netlify.app/posts/statistics/bayesian/fcb05/"},{"content":"Part 4. 데이터의 이해와 데이터베이스 본 포스팅은 패스트캠퍼스(FastCampus)의 데이터 엔지니어링 올인원 패키지 Online을 참고하였습니다.\n0. Data Type  numeric data/time character/string unicode character/string binary miscellaneous  1. Relational Database(RDB)  모든 데이터를 2차원의 테이블로 표현 하나 이상의 테이블로 구성 Entity-Relationship 모델 Normalization (Reduce Redundacy)  2. AWS 클라우드 MySQL 데이터베이스 생성  aws.amazon.com \u0026gt; RDS \u0026gt; 데이터 생성 Templates \u0026gt; Free Tier로 설정 (과금 예방) Public Access 허용하기 VPC에서 인바운드 규칙에 MySql 추가하기  3. 터미널에서 데이터베이스 연결하기 (Windows 기준)\n mysql client workbench 다운로드 MySQL Workbench랑 AWS를 연결하고, 그것을 termianl(powershell)로 연결하는 법 termianl에서 아래의 커맨드를 작성하고, 이어서 비밀번호를 입력해주면 된다.  mysql -h {hostname} -P 3306 -D {Default Schema} -u {username} -p\r4. MySQL 데이터베이스 안에서 테이블 생성 1 2  CREATE TABLE people (first_name VARCHAR(20), last_name VARCHAR(20), age INT); SHOW TABLES;   5. 엔터티 관계도(ERD)  Entity Relationship Diagram 데이터 모델링 설계 과정에서 사용하는 모델 약속된 기호를 이용하여 데이터베이스의 구조를 쉽게 이해하기 위함이다.  ERD의 기본요소  Entities: 개체 Attributes: 엔터티의 속성 Relationship: 엔터티 간의 관계  6. Primary Key \u0026amp; Unique Key Primary Key  테이블에 하나 밖에 없는 유니크한 구별 값 Null 값 안 됨  Foreign Key  한 개 이상 가능 NULL 값도 가능  Unique Key  Primary Key처럼 유니크하긴 하다. 하지만, Null 값은 하나는 가질 수 있다. 그리고 하나 이상의 유니크 키를 가질 수 있다. Primary Key보다는 index로서의 성능은 낮다. ex) Primary Key: 수험번호, Unique Key: 주민등록번호  ","description":"데이터의 이해와 데이터베이스","id":15,"section":"posts","tags":null,"title":"RDBMS","uri":"https://jiwooblog.netlify.app/posts/dataengineering/fc_part4_1/"},{"content":"Part 4. 데이터의 이해와 데이터베이스 본 포스팅은 패스트캠퍼스(FastCampus)의 데이터 엔지니어링 올인원 패키지 Online을 참고하였습니다.\n1. Spotify 데이터 이해 Spotify Web API \u0026gt; get an artist\nartist object 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  { \u0026#34;external_urls\u0026#34; : { \u0026#34;spotify\u0026#34; : \u0026#34;https://open.spotify.com/artist/0OdUWJ0sBjDrqHygGUXeCF\u0026#34; }, \u0026#34;followers\u0026#34; : { \u0026#34;href\u0026#34; : null, \u0026#34;total\u0026#34; : 306565 }, \u0026#34;genres\u0026#34; : [ \u0026#34;indie folk\u0026#34;, \u0026#34;indie pop\u0026#34; ], \u0026#34;href\u0026#34; : \u0026#34;https://api.spotify.com/v1/artists/0OdUWJ0sBjDrqHygGUXeCF\u0026#34;, \u0026#34;id\u0026#34; : \u0026#34;0OdUWJ0sBjDrqHygGUXeCF\u0026#34;, \u0026#34;images\u0026#34; : [ { \u0026#34;height\u0026#34; : 816, \u0026#34;url\u0026#34; : \u0026#34;https://i.scdn.co/image/eb266625dab075341e8c4378a177a27370f91903\u0026#34;, \u0026#34;width\u0026#34; : 1000 }, { \u0026#34;height\u0026#34; : 522, \u0026#34;url\u0026#34; : \u0026#34;https://i.scdn.co/image/2f91c3cace3c5a6a48f3d0e2fd21364d4911b332\u0026#34;, \u0026#34;width\u0026#34; : 640 }, { \u0026#34;height\u0026#34; : 163, \u0026#34;url\u0026#34; : \u0026#34;https://i.scdn.co/image/2efc93d7ee88435116093274980f04ebceb7b527\u0026#34;, \u0026#34;width\u0026#34; : 200 }, { \u0026#34;height\u0026#34; : 52, \u0026#34;url\u0026#34; : \u0026#34;https://i.scdn.co/image/4f25297750dfa4051195c36809a9049f6b841a23\u0026#34;, \u0026#34;width\u0026#34; : 64 } ], \u0026#34;name\u0026#34; : \u0026#34;Band of Horses\u0026#34;, \u0026#34;popularity\u0026#34; : 59, \u0026#34;type\u0026#34; : \u0026#34;artist\u0026#34;, \u0026#34;uri\u0026#34; : \u0026#34;spotify🧑‍🎨0OdUWJ0sBjDrqHygGUXeCF\u0026#34; }   2. Spotify 데이터 모델 예시 ","description":"데이터의 이해와 데이터베이스","id":16,"section":"posts","tags":null,"title":"Spotify Data","uri":"https://jiwooblog.netlify.app/posts/dataengineering/fc_part4_2/"},{"content":"Part 4. 데이터의 이해와 데이터베이스 본 포스팅은 패스트캠퍼스(FastCampus)의 데이터 엔지니어링 올인원 패키지 Online을 참고하였습니다.\n1. Pymysql 패키지 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  import sys import requests import base64 import json import logging import pymysql #New library client_id = \u0026#39;\u0026#39; #직접 입력 client_secret = \u0026#39;\u0026#39; # 직접 입력 host = \u0026#39;\u0026#39; #host port = 3306 username = \u0026#39;\u0026#39; #user database = \u0026#39;\u0026#39; #db password = \u0026#39;\u0026#39; #passwd def main(): try: conn = pymysql.connect(host=host, user=username, passwd=password, db=database, port=port, use_unicode=True, charset=\u0026#39;utf8\u0026#39;) cursor = conn.cursor() except: logging.error(\u0026#39;could not connect to RDS\u0026#39;) sys.exit(1) cursor.execute(\u0026#39;SHOW TABLES\u0026#39;) print(cursor.fetchall()) print(\u0026#39;success\u0026#39;) sys.exit(0) if __name__ == \u0026#39;__main__\u0026#39;: main()   2. INSERT, UPDATE, REPLACE, INSERT IGNORE 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  CREATE TABLE artists (id VARCHAR(255), name VARCHAR(255), followers INT, popularity INT, url VARCHAR(255), image_url VARCHAR(255), PRIMARY KEY(id)) ENGINE=InnoDB DEFAULT CHARSET=\u0026#39;utf8\u0026#39;; CREATE TABLE artist_genres (artist_id VARCHAR(255), genre VARCHAR(255)) ENGINE=InnoDB DEFAULT CHARSET=\u0026#39;utf8\u0026#39;; SHOW CREATE TABLE artists; -- INSERT INSERT INTO artist_genres (artist_id, genre) VALUES (\u0026#39;1234\u0026#39;, \u0026#39;pop\u0026#39;); DELETE FROM artist_genres; --제거 DROP TABLE artist_genres; --제거 CREATE TABLE artist_genres (artist_id VARCHAR(255), genre VARCHAR(255), UNIQUE KEY(artist_id, genre)) ENGINE=InnoDB DEFAULT CHARSET=\u0026#39;utf8\u0026#39;; --unique key 생성 INSERT INTO artist_genres (artist_id, genre) VALUES (\u0026#39;1234\u0026#39;, \u0026#39;pop\u0026#39;); INSERT INTO artist_genres (artist_id, genre) VALUES (\u0026#39;1234\u0026#39;, \u0026#39;pop\u0026#39;); --두 번 하면 ERROR  -- UPDATE UPDATE artist_genres SET genre=\u0026#39;pop\u0026#39; WHERE artist_id =\u0026#39;1234\u0026#39;; ALTER TABLE artist_genres ADD COLUMN country VARCHAR(255); ALTER TABLE artist_genres ADD COLUMN updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP; --업데이트되는 시각대 자동추가 INSERT INTO artist_genres (artist_id, genre, country) VALUES (\u0026#39;1234\u0026#39;,\u0026#39;pop\u0026#39;,\u0026#39;UK\u0026#39;); -- 오류 발생함  -- REPLACE REPLACE INTO artist_genres (artist_id, genre, country) VALUES (\u0026#39;1234\u0026#39;,\u0026#39;pop\u0026#39;,\u0026#39;UK\u0026#39;); /* 문제점(1) 지우고 업데이트하기 때문에 2번의 과정을 거쳐서 퍼포먼스적으로 문제 생길 수가 있다. 문제점(2) primary key가 auto_increment인 경우 새로운 숫자로 바뀌게 된다. */ -- INSERT IGNORE INSERT IGNORE INTO artist_genres (artist_id, genre, country) VALUES (\u0026#39;1234\u0026#39;,\u0026#39;rock\u0026#39;,\u0026#39;UK\u0026#39;); /* 문제점(1) 이미 값이 있으면 추가하지 않게 된다.*/ -- INSERT ... ON DUPLICATE KEY UPDATE INSERT INTO artist_genres (artist_id, genre, country) VALUES (\u0026#39;1234\u0026#39;,\u0026#39;rock\u0026#39;,\u0026#39;UK\u0026#39;) ON DUPLICATE KEY UPDATE artist_id=\u0026#39;1234\u0026#39;, genre=\u0026#39;rock\u0026#39;, country=\u0026#39;FR\u0026#39;; --UK를 FR로 바꾼다.  -- ETC ALTER TABLE artist_genres DROP COLUMN country; --불필요한 칼럼 지우기   *MySQL에서 진행하였다.\n특이사항  data type을 INTEGER로 하니까 안 되고, INT로 하니까 됐다.  3. _, .format() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  def main(): try: conn = pymysql.connect(host=host, user=username, passwd=password, db=database, port=port, use_unicode=True, charset=\u0026#39;utf8\u0026#39;) cursor = conn.cursor() except: logging.error(\u0026#39;could not connect to RDS\u0026#39;) sys.exit(1) cursor.execute(\u0026#39;SHOW TABLES\u0026#39;) print(cursor.fetchall()) query = \u0026#34;INSERT INTO artist_genres (artist_id, genre) VALUES (\u0026#39;{0}\u0026#39;, \u0026#39;{1}\u0026#39;)\u0026#34;.format(\u0026#39;2345\u0026#39;,\u0026#39;hip-hop\u0026#39;) cursor.execute(query) conn.commit() sys.exit(0) if __name__ == \u0026#39;__main__\u0026#39;: main()   4. Dictionary와 JSON Package 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  def main(): try: conn = pymysql.connect(host=host, user=username, passwd=password, db=database, port=port, use_unicode=True, charset=\u0026#39;utf8\u0026#39;) cursor = conn.cursor() except: logging.error(\u0026#39;could not connect to RDS\u0026#39;) sys.exit(1) headers = get_headers(client_id, client_secret) ## Spotify Search api params = { \u0026#39;q\u0026#39;: \u0026#39;BTS\u0026#39;, \u0026#39;type\u0026#39;: \u0026#39;artist\u0026#39;, \u0026#39;limit\u0026#39;: \u0026#39;5\u0026#39; } r = requests.get(\u0026#39;https://api.spotify.com/v1/search\u0026#39;, params=params, headers=headers) raw = json.loads(r.text) print(raw[\u0026#39;artists\u0026#39;].keys) def get_headers(client_id, client_secret): endpoint = \u0026#39;https://accounts.spotify.com/api/token\u0026#39; encoded = base64.b64encode(\u0026#34;{}:{}\u0026#34;.format(client_id, client_secret).encode(\u0026#39;utf-8\u0026#39;)).decode(\u0026#39;ascii\u0026#39;) headers = {\u0026#39;Authorization\u0026#39;: \u0026#39;Basic {}\u0026#39;.format(encoded)} payload = {\u0026#39;grant_type\u0026#39;: \u0026#39;client_credentials\u0026#39;} r = requests.post(endpoint, data=payload, headers=headers) access_token = json.loads(r.text)[\u0026#39;access_token\u0026#39;] headers = {\u0026#39;Authorization\u0026#39;: \u0026#34;Bearer {}\u0026#34;.format(access_token)} return headers if __name__ == \u0026#39;__main__\u0026#39;: main()   5. Duplicate Record 핸들링 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  def main(): try: conn = pymysql.connect(host=host, user=username, passwd=password, db=database, port=port, use_unicode=True, charset=\u0026#39;utf8\u0026#39;) cursor = conn.cursor() except: logging.error(\u0026#39;could not connect to RDS\u0026#39;) sys.exit(1) headers = get_headers(client_id, client_secret) ## Spotify Search api params = { \u0026#39;q\u0026#39;: \u0026#39;BTS\u0026#39;, \u0026#39;type\u0026#39;: \u0026#39;artist\u0026#39;, \u0026#39;limit\u0026#39;: \u0026#39;1\u0026#39; } r = requests.get(\u0026#39;https://api.spotify.com/v1/search\u0026#39;, params=params, headers=headers) raw = json.loads(r.text) artist_raw = raw[\u0026#39;artists\u0026#39;][\u0026#39;items\u0026#39;][0] if artist_raw[\u0026#39;name\u0026#39;] == params[\u0026#39;q\u0026#39;]: artist = { \u0026#39;id\u0026#39;: artist_raw[\u0026#39;id\u0026#39;], \u0026#39;name\u0026#39;: artist_raw[\u0026#39;name\u0026#39;], \u0026#39;followers\u0026#39;: artist_raw[\u0026#39;followers\u0026#39;][\u0026#39;total\u0026#39;], \u0026#39;popularity\u0026#39;: artist_raw[\u0026#39;popularity\u0026#39;], \u0026#39;url\u0026#39;: artist_raw[\u0026#39;external_urls\u0026#39;][\u0026#39;spotify\u0026#39;], \u0026#39;image_url\u0026#39;: artist_raw[\u0026#39;images\u0026#39;][0][\u0026#39;url\u0026#39;] } query = \u0026#34;\u0026#34;\u0026#34; INSERT INTO artists (id, name, followers, popularity, url, image_url) VALUES (\u0026#39;{}\u0026#39;, \u0026#39;{}\u0026#39;, {}, {}, \u0026#39;{}\u0026#39;, \u0026#39;{}\u0026#39;) ON DUPLICATE KEY UPDATE id=\u0026#39;{}\u0026#39;, name=\u0026#39;{}\u0026#39;, followers={}, popularity={}, url=\u0026#39;{}\u0026#39;, image_url=\u0026#39;{}\u0026#39; \u0026#34;\u0026#34;\u0026#34;.format( artist[\u0026#39;id\u0026#39;], artist[\u0026#39;name\u0026#39;], artist[\u0026#39;followers\u0026#39;], artist[\u0026#39;popularity\u0026#39;], artist[\u0026#39;url\u0026#39;], artist[\u0026#39;image_url\u0026#39;], artist[\u0026#39;id\u0026#39;], artist[\u0026#39;name\u0026#39;], artist[\u0026#39;followers\u0026#39;], artist[\u0026#39;popularity\u0026#39;], artist[\u0026#39;url\u0026#39;], artist[\u0026#39;image_url\u0026#39;] ) cursor.execute(query) conn.commit()   6. Duplicate Record 핸들링을 위한 파이썬 함수 5와 다른 점을 눈여겨 보기 (5를 보다 간단하게 한 코드) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  def main(): ## .... 여기까지는 위와 동일 r = requests.get(\u0026#39;https://api.spotify.com/v1/search\u0026#39;, params=params, headers=headers) raw = json.loads(r.text) artist = {} artist_raw = raw[\u0026#39;artists\u0026#39;][\u0026#39;items\u0026#39;][0] if artist_raw[\u0026#39;name\u0026#39;] == params[\u0026#39;q\u0026#39;]: artist.update({ \u0026#39;id\u0026#39;: artist_raw[\u0026#39;id\u0026#39;], \u0026#39;name\u0026#39;: artist_raw[\u0026#39;name\u0026#39;], \u0026#39;followers\u0026#39;: artist_raw[\u0026#39;followers\u0026#39;][\u0026#39;total\u0026#39;], \u0026#39;popularity\u0026#39;: artist_raw[\u0026#39;popularity\u0026#39;], \u0026#39;url\u0026#39;: artist_raw[\u0026#39;external_urls\u0026#39;][\u0026#39;spotify\u0026#39;], \u0026#39;image_url\u0026#39;: artist_raw[\u0026#39;images\u0026#39;][0][\u0026#39;url\u0026#39;] }) insert_row(cursor, data=artist, table=\u0026#39;artists\u0026#39;) conn.commit() def insert_row(cursor, data, table): placeholders = \u0026#39;, \u0026#39;.join([\u0026#39;%s\u0026#39;] * len(data)) columns = \u0026#39;, \u0026#39;.join(data.keys()) key_placeholders = \u0026#39;, \u0026#39;.join([\u0026#39;{0}=%s\u0026#39;.format(k) for k in data.keys()]) sql = \u0026#39;INSERT INTO %s( %s) VALUES ( %s) ON DUPLICATE KEY UPDATE %s\u0026#39; % (table, columns, placeholders, key_placeholders) cursor.execute(sql, list(data.values())*2)   7. Artist list 추출하기  패스트캠퍼스 강좌를 통해 제공된 artist_list.csv 파일을 활용하였다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  def main(): try: conn = pymysql.connect(host=host, user=username, passwd=password, db=database, port=port, use_unicode=True, charset=\u0026#39;utf8\u0026#39;) cursor = conn.cursor() except: logging.error(\u0026#39;could not connect to RDS\u0026#39;) sys.exit(1) headers = get_headers(client_id, client_secret) artists = [] with open(\u0026#39;../artist_list.csv\u0026#39;, encoding=\u0026#34;utf-8\u0026#34;) as f: raw = csv.reader(f) for row in raw: artists.append(row[0]) for a in artists: params = { \u0026#39;q\u0026#39;: a, \u0026#39;type\u0026#39;: \u0026#39;artist\u0026#39;, \u0026#39;limit\u0026#39;: \u0026#39;1\u0026#39; } r = requests.get(\u0026#39;https://api.spotify.com/v1/search\u0026#39;, params=params, headers=headers) raw = json.loads(r.text) artist = {} try: if raw[\u0026#39;artists\u0026#39;][\u0026#39;items\u0026#39;][0][\u0026#39;name\u0026#39;] == params[\u0026#39;q\u0026#39;]: artist.update( { \u0026#39;id\u0026#39;: raw[\u0026#39;artists\u0026#39;][\u0026#39;items\u0026#39;][0][\u0026#39;id\u0026#39;], \u0026#39;name\u0026#39;: raw[\u0026#39;artists\u0026#39;][\u0026#39;items\u0026#39;][0][\u0026#39;name\u0026#39;], \u0026#39;followers\u0026#39;: raw[\u0026#39;artists\u0026#39;][\u0026#39;items\u0026#39;][0][\u0026#39;followers\u0026#39;][\u0026#39;total\u0026#39;], \u0026#39;popularity\u0026#39;: raw[\u0026#39;artists\u0026#39;][\u0026#39;items\u0026#39;][0][\u0026#39;popularity\u0026#39;], \u0026#39;url\u0026#39;: raw[\u0026#39;artists\u0026#39;][\u0026#39;items\u0026#39;][0][\u0026#39;external_urls\u0026#39;][\u0026#39;spotify\u0026#39;], \u0026#39;image_url\u0026#39;: raw[\u0026#39;artists\u0026#39;][\u0026#39;items\u0026#39;][0][\u0026#39;images\u0026#39;][0][\u0026#39;url\u0026#39;] } ) insert_row(cursor, artist, \u0026#39;artists\u0026#39;) except: logging.error(\u0026#39;NO ITEMS FROM SEARCH API\u0026#39;) continue conn.commit() # sys.exit(0)   ERROR:root:NO ITEMS FROM SEARCH API와 같은 에러가 여러 개가 나오게 된다.\n말그대로 SERACH API를 통해서 ITEMS를 찾지 못하게 된 경우에 해당한다.\n8. Batch 형식으로 데이터 요청  한번에 묶어서 API에 전달하는 방식이다. 모든 API가 제공하는 것은 아니긴 하다! Spotify는 \u0026lsquo;Get Several Artists\u0026rsquo;하는 법을 제공하고 있다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  def main(): try: conn = pymysql.connect(host=host, user=username, passwd=password, db=database, port=port, use_unicode=True, charset=\u0026#39;utf8\u0026#39;) cursor = conn.cursor() except: logging.error(\u0026#39;could not connect to RDS\u0026#39;) sys.exit(1) headers = get_headers(client_id, client_secret) cursor.execute(\u0026#34;SELECT id FROM artists\u0026#34;) artists = [] for (id, ) in cursor.fetchall(): artists.append(id) artist_batch = [artists[i: i+50] for i in range(0, len(artists), 50)] for i in artist_batch: ids = \u0026#39;,\u0026#39;.join(i) URL = \u0026#39;https://api.spotify.com/v1/artists/?ids={}\u0026#39;.format(ids) r= requests.get(URL, headers=headers) raw = json.loads(r.text) print(raw) print(len(raw[\u0026#39;artists\u0026#39;])) sys.exit(0)   1 2  -- 제대로 잘 들어갔는지 확인해보기 select * from artist_genres limit 10;   9. MySQL 테이블들로 데이터 저장 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  def main(): ## ... 여기까지는 위와 똑같음 artist_batch = [artists[i: i+50] for i in range(0, len(artists), 50)] artist_genres = [] for i in artist_batch: ids = \u0026#39;,\u0026#39;.join(i) URL = \u0026#39;https://api.spotify.com/v1/artists/?ids={}\u0026#39;.format(ids) r= requests.get(URL, headers=headers) raw = json.loads(r.text) for artist in raw[\u0026#39;artists\u0026#39;]: for genre in artist[\u0026#39;genres\u0026#39;]: artist_genres.append( { \u0026#39;artist_id\u0026#39;: artist[\u0026#39;id\u0026#39;], \u0026#39;genre\u0026#39;: genre } ) for data in artist_genres: insert_row(cursor, data, \u0026#39;artist_genres\u0026#39;) conn.commit() sys.exit(0) ## ... 아래도 다 똑같음   \n","description":"데이터의 이해와 데이터베이스","id":17,"section":"posts","tags":null,"title":"Python \u0026 MySQL","uri":"https://jiwooblog.netlify.app/posts/dataengineering/fc_part4_3/"},{"content":"Part 4. 데이터의 이해와 데이터베이스 본 포스팅은 패스트캠퍼스(FastCampus)의 데이터 엔지니어링 올인원 패키지 Online을 참고하였습니다.\n1. Artist Data 1  SELECT genre, COUNT(*) FROM artist_genres GROUP BY 1 ORDER BY 2 DESC LIMIT 20;   2. Artist Genre Analysis with SQL 1 2 3  SELECT popularity, name FROM artists ORDER BY 1 DESC LIMIT 20; SELECT genre, COUNT(*) FROM artists t1 JOIN artist_genres t2 ON t2.artist_id = t1.id WHERE t1.popularity \u0026gt; 80 GROUP BY 1 ORDER BY 2 DESC LIMIT 20;    join을 통해 ERD의 장점을 활용하여 기초분석을 할 수 있다.  ","description":"데이터의 이해와 데이터베이스","id":18,"section":"posts","tags":null,"title":"SQL 활용 (MySQL)","uri":"https://jiwooblog.netlify.app/posts/dataengineering/fc_part4_4/"},{"content":"Part 4. 데이터의 이해와 데이터베이스 본 포스팅은 패스트캠퍼스(FastCampus)의 데이터 엔지니어링 올인원 패키지 Online을 참고하였습니다.\n이 포스팅은 NoSQL 중 DynamoDB를 위주로 서술되어 있습니다.\n1. NoSQL vs. RDB  Not Only SQL 차이점(1) 다이나믹 스키마  구조를 정의하지 않고도 Documents, Key Values 등을 생성 각각의 Document가 서로 다른 구조로 구성 가능 데이터베이스들마다 다른 syntax 필드 추가 가능   차이점(2) Scalabilty  SQL DB: vertically scalable - CPU, RAM, SSD로 용량 문제 해결결 NoSQL DB: horizontally scalable - Sharding, Partitioning로 용량 문제 해결    2. Partition  데이터 나누기(vertical \u0026amp; horizontal)  데이터 매니지먼트, 퍼포먼스 등 다양한 이유     Vertical Partition  테이블을 더 작은 테이블로 나누기(Normalization와는 다름) ex. 지속적으로 업데이트되는 칼럼과 아닌 칼럼들 나누기   Horizontal Partition  Schema / Structure 자체를 복사하여 데이터 자체를 Sharded Key로 분리 NosQL DB에서는 필수적이다.    3. DynamoDB  aws.amazon.com \u0026gt; DynamoDB Partition Key는 SQL에서 Primary Key와 유사하다.  4. AWS SDK - Boto3 Package (DynamoDB 연결) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  import sys import os import boto3 import logging def main(): try: dynamodb = boto3.resource(\u0026#39;dynamodb\u0026#39;, region_name=\u0026#39;ap-northeast-2\u0026#39;, endpoint_url=\u0026#39;http://dynamodb.ap-northeast-2.amazonaws.com\u0026#39;) except: logging.error(\u0026#34;could not connect to dynamodb\u0026#34;) sys.exit(1) print(\u0026#39;Success\u0026#39;) if __name__==\u0026#39;__main__\u0026#39;: main()   5. 테이블 생성 및 스펙  Provisioned(할당됨) vs. On-demand(온디맨드)  6. Global Index, Local Index 7. INSERT(Single, Batch items) boto3 Documentation 읽어보기\nCreating a New Item 1 2 3 4 5 6 7 8 9  table.put_item( Item={ \u0026#39;username\u0026#39;: \u0026#39;janedoe\u0026#39;, \u0026#39;first_name\u0026#39;: \u0026#39;Jane\u0026#39;, \u0026#39;last_name\u0026#39;: \u0026#39;Doe\u0026#39;, \u0026#39;age\u0026#39;: 25, \u0026#39;account_type\u0026#39;: \u0026#39;standard_user\u0026#39;, } )   Batch Writing 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61  with table.batch_writer() as batch: batch.put_item( Item={ \u0026#39;account_type\u0026#39;: \u0026#39;standard_user\u0026#39;, \u0026#39;username\u0026#39;: \u0026#39;johndoe\u0026#39;, \u0026#39;first_name\u0026#39;: \u0026#39;John\u0026#39;, \u0026#39;last_name\u0026#39;: \u0026#39;Doe\u0026#39;, \u0026#39;age\u0026#39;: 25, \u0026#39;address\u0026#39;: { \u0026#39;road\u0026#39;: \u0026#39;1 Jefferson Street\u0026#39;, \u0026#39;city\u0026#39;: \u0026#39;Los Angeles\u0026#39;, \u0026#39;state\u0026#39;: \u0026#39;CA\u0026#39;, \u0026#39;zipcode\u0026#39;: 90001 } } ) batch.put_item( Item={ \u0026#39;account_type\u0026#39;: \u0026#39;super_user\u0026#39;, \u0026#39;username\u0026#39;: \u0026#39;janedoering\u0026#39;, \u0026#39;first_name\u0026#39;: \u0026#39;Jane\u0026#39;, \u0026#39;last_name\u0026#39;: \u0026#39;Doering\u0026#39;, \u0026#39;age\u0026#39;: 40, \u0026#39;address\u0026#39;: { \u0026#39;road\u0026#39;: \u0026#39;2 Washington Avenue\u0026#39;, \u0026#39;city\u0026#39;: \u0026#39;Seattle\u0026#39;, \u0026#39;state\u0026#39;: \u0026#39;WA\u0026#39;, \u0026#39;zipcode\u0026#39;: 98109 } } ) batch.put_item( Item={ \u0026#39;account_type\u0026#39;: \u0026#39;standard_user\u0026#39;, \u0026#39;username\u0026#39;: \u0026#39;bobsmith\u0026#39;, \u0026#39;first_name\u0026#39;: \u0026#39;Bob\u0026#39;, \u0026#39;last_name\u0026#39;: \u0026#39;Smith\u0026#39;, \u0026#39;age\u0026#39;: 18, \u0026#39;address\u0026#39;: { \u0026#39;road\u0026#39;: \u0026#39;3 Madison Lane\u0026#39;, \u0026#39;city\u0026#39;: \u0026#39;Louisville\u0026#39;, \u0026#39;state\u0026#39;: \u0026#39;KY\u0026#39;, \u0026#39;zipcode\u0026#39;: 40213 } } ) batch.put_item( Item={ \u0026#39;account_type\u0026#39;: \u0026#39;super_user\u0026#39;, \u0026#39;username\u0026#39;: \u0026#39;alicedoe\u0026#39;, \u0026#39;first_name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;last_name\u0026#39;: \u0026#39;Doe\u0026#39;, \u0026#39;age\u0026#39;: 27, \u0026#39;address\u0026#39;: { \u0026#39;road\u0026#39;: \u0026#39;1 Jefferson Street\u0026#39;, \u0026#39;city\u0026#39;: \u0026#39;Los Angeles\u0026#39;, \u0026#39;state\u0026#39;: \u0026#39;CA\u0026#39;, \u0026#39;zipcode\u0026#39;: 90001 } } )   8. 데이터 요청 및 제한점 boto3 Documentation 읽어보기\nGetting an Item 1 2 3 4 5 6  response = table.get_item( Key = { \u0026#39;artist_id\u0026#39;: \u0026#39;00FQb4jTyendYWaN8pK0wa\u0026#39;, \u0026#39;id\u0026#39;: \u0026#39;0Oqc0kKFsQ6MhFOLBNZIGX\u0026#39; } )   ClientError: An error occurred (ValidationException) when calling the GetItem operation: The provided key element does not match the schema\r위와 같은 에러가 뜬다면, key값을 제대로 다 넣었는지 확인해본다.\nQuerying and Scanning  Querying: Primary Key 값을 알고 있을 때 활용 Scanning: Primary Key 값을 모르지만, 다른 attribute를 알 때 활용\n- Scan은 모든 행을 다 훑는 비효율적인 기능이므로 꼭 필요할 때만 쓰는 것이 권장된다.  1 2 3 4 5 6 7 8 9 10 11 12  # Querying response = table.query( KeyConditionExpression=Key(\u0026#39;artist_id\u0026#39;).eq(\u0026#39;00FQb4jTyendYWaN8pK0wa\u0026#39;), FilterExpression=Attr(\u0026#39;popularity\u0026#39;).gt(75) #query도 filterexpresson 쓸 수 있다! ) print(len(response[\u0026#39;Items\u0026#39;])) # Scanning response = table.scan( FilterExpression=Attr(\u0026#39;popularity\u0026#39;).gt(75) ) print(len(response[\u0026#39;Items\u0026#39;]))   \n","description":"데이터의 이해와 데이터베이스","id":19,"section":"posts","tags":null,"title":"NoSQL (DynamoDB)","uri":"https://jiwooblog.netlify.app/posts/dataengineering/fc_part4_5/"},{"content":"Part 5. 데이터 엔지니어링 구축 본 포스팅은 패스트캠퍼스(FastCampus)의 데이터 엔지니어링 올인원 패키지 Online을 참고하였습니다.\n1. 데이터 레이크 vs. 데이터 웨어하우스    구분 데이터 레이크 데이터 웨어하우스     Data Structure Raw Processed   Purpose of Data Not yet Determined In Use   Users Data Scientists Business Professionals   Accessibility High / Quick to update Complicated / Costly     Schema의 차이가 가장 크다. 데이터레이크는 차세대 시스템으로서 더욱 주목 받게 될 것이다. ETL(Extract-Transform-Load)  2. 데이터 레이크 아키텍처 데이터 파이프라인의 관심사  어떻게 관리 스케쥴링 에러 핸들링 데이터 백필  3. AWS S3  AWS S3 버킷 생성 cf. AWS Glue: table schema 관리 (데이터 레이크는 바뀐다.)  4. JSON, Parquet 1 2 3 4 5  # JSON 형식으로 하는 법 with open(\u0026#39;top_tracks.json\u0026#39;, \u0026#39;w\u0026#39;) as f: for i in top_tracks: json.dump(i, f) f.write(os.linesep)   1 2 3 4 5 6 7 8 9 10 11  # Parquet 형식으로 하는 법 # 퍼포먼스적으로 우수해진다. top_tracks = pd.DataFrame(raw) top_tracks.to_parquet(\u0026#39;top-tracks.parquet\u0026#39;, engine=\u0026#39;pyarrow\u0026#39;, compressions=\u0026#39;snappy\u0026#39;) dt = datetime.utcnow().strftime(\u0026#34;%Y-%m-%d\u0026#34;) s3 = boto3.resource(\u0026#39;s3\u0026#39;) object = s3.Object(\u0026#39;spotify-artists\u0026#39;, \u0026#39;dt={}/top-tracks.parquet\u0026#39;.format(dt)) data = open(\u0026#39;top-tracks.parquet\u0026#39;, \u0026#39;rb\u0026#39;) object.put(Body=data)   5. S3 Data Lake ImportError: Missing optional dependency 'pyarrow'. pyarrow is required for parquet support. Use pip or conda to install pyarrow.\rSpotify audio features\n","description":"데이터 엔지니어링 구축","id":20,"section":"posts","tags":null,"title":"데이터 레이크","uri":"https://jiwooblog.netlify.app/posts/dataengineering/fc_part5_1/"},{"content":"Part 5. 데이터 엔지니어링 구축 본 포스팅은 패스트캠퍼스(FastCampus)의 데이터 엔지니어링 올인원 패키지 Online을 참고하였습니다.\n1. Presto 2. Serverless 3. AWS Athena 4. 테이블 생성 5. 데이터 쿼리 ","description":"데이터 엔지니어링 구축","id":21,"section":"posts","tags":null,"title":"S3 Athena","uri":"https://jiwooblog.netlify.app/posts/dataengineering/fc_part5_2/"},{"content":"Part 5. 데이터 엔지니어링 구축 본 포스팅은 패스트캠퍼스(FastCampus)의 데이터 엔지니어링 올인원 패키지 Online을 참고하였습니다.\n1. Apache Spark 2. EC-2 제플린 인스턴스 생성 ","description":"데이터 엔지니어링 구축","id":22,"section":"posts","tags":null,"title":"Apache Spark","uri":"https://jiwooblog.netlify.app/posts/dataengineering/fc_part5_3/"},{"content":"Part 5. 데이터 엔지니어링 구축 본 포스팅은 패스트캠퍼스(FastCampus)의 데이터 엔지니어링 올인원 패키지 Online을 참고하였습니다.\n1. Spark RDD 2. Spark Dataframes 3. Select Subset Columns 4. Filter Rows 5. Create UDF 6. Join 7. SQL 8. 데이터분석 with Spark 9. 시각화 with Spark ","description":"데이터 엔지니어링 구축","id":23,"section":"posts","tags":null,"title":"Pyspark","uri":"https://jiwooblog.netlify.app/posts/dataengineering/fc_part5_4/"},{"content":"빅콘테스트 챔피언리그 데이터분석 분야\n배운 점\n 자연어 전처리   정규표현식 기존에 제시된 칼럼의 수가 굉장히 적었다. 그중에서 그나마 정보를 담고 있는 것은 \u0026lsquo;상품명\u0026rsquo; 칼럼이었다. 이 데이터를 예를 들어, \u0026lsquo;NIKE 스트라이프 셔츠\u0026rsquo;와 같은 형식으로 브랜드가 일반적으로 앞에 나오고 뒤에 디테일한 상품 분류가 나왔다. 하지만 식료품과 같은 경우에는 브랜드가 없는 것들이 많았고, 띄어쓰기가 제대로 되어있지 않은 경우도 많았다. (아마도 현실 데이터는 이것보다도 더 정돈되지 않은 경우가 많을 터이다\u0026hellip;) 또한 브랜드의 표기 자체가 통일되지 않은 경우가 있었다.(ex. 카사미아=까사미아) NS Shop+ 공식홈페이지에서 나눠놓은 대분류, 중분류, 소분류 체계를 참고해서 나눴다. 너무 많은 상품명이 있었기 때문에, 대분류 3개씩 묶어서 역할분담을 해서 나머지 분류를 채웠는데, 그러다보니 사소하게 통일되지 않은 분류기준이 있어서 추후 약간의 어려움을 겪었다. 기준을 명확하게 정해두거나, 만약 그러지 못할 경우 최소한의 사람이 해당 업무를 했으면 어땠을까라는 생각이 든다. ","description":"","id":24,"section":"blog","tags":null,"title":"빅콘테스트 NS Shop+ 홈쇼핑 실적 예측","uri":"https://jiwooblog.netlify.app/blog/bigcontest2020/"},{"content":"마크다운 가이드라인\nLorem est tota propiore conpellat pectoribus de\npectora summo. Redit teque digerit hominumque toris verebor lumina non cervice\nsubde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc\ncaluere tempus\nThis article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\n\rHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution  Tiam, ad mint andaepu dandae nostion secatur sequo quae.\nNote that you can use Markdown syntax within a blockquote.\n Blockquote with attribution  Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\n Tables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\n   Name Age     Bob 27   Alice 23    Inline Markdown within tables    Inline  Markdown  In  Table     italics bold strikethrough  code    Code Blocks Code block with backticks html\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\rCode block indented with four spaces \u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   List Types Ordered List  First item Second item Third item  Unordered List  List item Another item And another item  Nested list  Item  First Sub-item Second Sub-item    Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\n The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015. \u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":25,"section":"blog","tags":["markdown"],"title":"Markdown Syntax Guide","uri":"https://jiwooblog.netlify.app/blog/markdown-syntax/"},{"content":"Youtube 링크 거는 법\nHugo ships with several Built-in Shortcodes for rich content, along with a Privacy Config and a set of Simple Shortcodes that enable static and no-JS versions of various social media embeds.\n\rYoutube 링크는 이렇게 하기!   ","description":"","id":26,"section":"blog","tags":["Youtube"],"title":"How to Link","uri":"https://jiwooblog.netlify.app/blog/rich-content/"},{"content":"이건 정확히 무엇인지 모르겠다..\nVagus elidunt \nThe Van de Graaf Canon\n","description":"","id":27,"section":"blog","tags":null,"title":"Placeholder Text","uri":"https://jiwooblog.netlify.app/blog/placeholder-text/"},{"content":"이모지 관련\nLorem est tota propiore conpellat pectoribus de pectora summo. Redit teque digerit hominumque toris verebor lumina non cervice\nsubde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc\ncaluere tempus\nEmoji can be enabled in a Hugo project in a number of ways.\n\rThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site’s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 🙈 🙉 🙉 🙊 🙊\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3  .emoji { font-family: Apple Color Emoji,Segoe UI Emoji,NotoColorEmoji,Segoe UI Symbol,Android Emoji,EmojiSymbols; }  ","description":"","id":28,"section":"blog","tags":["emoji"],"title":"Emoji Support","uri":"https://jiwooblog.netlify.app/blog/emoji-support/"}]